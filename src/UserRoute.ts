import { HotRoute, HotDBMySQL, HotServerType, 
	ConnectionStatus, HotStaq, 
	Hot, HotTestDriver, HotAPI, ServerRequest, DeveloperMode } from "hotstaq";

import { IJWTToken, IUser, User } from "./User";

/**
 * The User route.
 */
export class UserRoute extends HotRoute
{
	/**
	 * The database connection.
	 */
	db: HotDBMySQL;
	/**
	 * Executes when the route is registering. This is helpful for 
	 * creating tables, installing fixtures, etc. If not set, 
	 * this will call User.syncTables by default.
	 */
	onRegisteringRoute: ((db: HotDBMySQL) => Promise<void>);

	constructor (api: HotAPI)
	{
		super (api.connection, "users");

		this.onRegisteringRoute = async (db: HotDBMySQL) =>
			{
				let isDebug: boolean = false;

				if (this.connection.processor.mode === DeveloperMode.Development)
					isDebug = true;

				await User.syncTables (this.db, isDebug);
			};

		if (HotStaq.isWeb === false)
		{
			this.onRegister = async () =>
				{
					if (api.connection.type !== HotServerType.Generate)
					{
						if (process.env["DATABASE_DISABLE"] != null)
						{
							if (process.env["DATABASE_DISABLE"] === "1")
								return (true);
						}

						this.db = (<HotDBMySQL>this.connection.api.db);

						if (this.db.connectionStatus !== ConnectionStatus.Connected)
							return (true);

						if (this.onRegisteringRoute != null)
							await this.onRegisteringRoute (this.db);
					}

					return (true);
				};
		}

		this.addMethod ({
				"name": "register",
				"onServerExecute": this.register,
				"description": `Registers a new user. If the user already exists, this will return an error. Additionally, if the new user is not verified manually, a verification code will be autogenerated and placed into the database.`,
				"parameters": {
					"user": {
						"type": "object",
						"required": true,
						"parameters": {
							"email": {
									"type": "string",
									"required": true,
									"description": "The user's email."
								},
							"password": {
									"type": "string",
									"required": true,
									"description": "The user's password."
								}
							}
					}
				},
				"returns": "Returns true when the user has been registered successfully.",
				"testCases": [
					"registerTest",
					async (driver: HotTestDriver): Promise<any> =>
					{
						let tempUser: User = await User.getUser (this.db, "test3@freelight.org");
				
						if (tempUser != null)
							await User.deleteUser (this.db, tempUser);

						// @ts-ignore
						let resp = await api.users.register ({
								user: {
									"email": "test3@freelight.org",
									"password": "se45se45sdfrg3456"
								}
							});

						driver.persistentData.verifyCode = resp.verifyCode;

						driver.assert (driver.persistentData.verifyCode !== "", "User registration did not complete!");
						/// @todo Check the database and make sure the user is there.
					}
				]
			});
		this.addMethod ({
				"name": "verifyUser",
				"onServerExecute": this.verifyUser,
				"description": "Verify a user's email address.",
				"parameters": {
					"email": {
							"type": "string",
							"required": true,
							"description": "The user's email."
						},
					"verificationCode": {
							"type": "string",
							"required": true,
							"description": "The user's verification code."
						}
				},
				"returns": "Returns true when the user has been verified successfully.",
				"testCases": [
					"verifyUserTest",
					async (driver: HotTestDriver): Promise<any> =>
					{
						// @ts-ignore
						let resp = await api.users.verifyUser ({
								"email": "test3@freelight.org",
								"verificationCode": driver.persistentData.verifyCode
							});

						driver.assert (resp === true, "User verification did not complete!");
						/// @todo Check the database and make sure the user is there.
					}
				]
			});
		this.addMethod ({
				"name": "login",
				"onServerExecute": this.login, 
				"parameters": {
					"user": {
						"type": "object",
						"required": true,
						"parameters": {
							"email": {
									"type": "string",
									"required": true,
									"description": "The user's email."
								},
							"password": {
									"type": "string",
									"required": true,
									"description": "The user's password."
								}
							}
					}
				},
				"returns": {
					"type": "object",
					"parameters": {
						"enabled": {
								"type": "boolean",
								"description": "Is the user enabled?"
							},
						"firstName": {
								"type": "string",
								"description": "The user's first name."
							},
						"lastName": {
								"type": "string",
								"description": "The user's last name."
							},
						"email": {
								"type": "string",
								"description": "The user's email."
							},
						"password": {
								"type": "string",
								"description": "This will return as an empty string."
							},
						"jwtToken": {
								"type": "string",
								"description": "The JWT token used to authenticate with."
							}
					}
				},
				"testCases": [
					"loginTest",
					async (driver: HotTestDriver): Promise<any> =>
					{
						// @ts-ignore
						let resp = await api.users.login ({
								user: {
									"email": "test3@freelight.org",
									"password": "se45se45sdfrg3456"
								}
							});

						driver.persistentData.jwtToken = resp.jwtToken;

						driver.assert (resp.password == null, "User object returning password!");
						driver.assert (resp.passwordSalt == null, "User object returning password!");
						driver.assert (resp.email !== "", "User login did not complete!");
						/// @todo Check the database and make sure the user is there.
					},
					"userLoginTest",
					async (driver: HotTestDriver): Promise<any> =>
					{
						let tempUser: User = await User.getUser (this.db, "test3@freelight.org");
				
						if (tempUser == null)
							throw new Error (`User test3@freelight.org not found!`);

						let logins: any[] = await User.getUserLogins (this.db, tempUser);

						driver.assert (logins.length === 0, "User login did not complete!");
					}
				]
			});
		this.addMethod ({
				"name": "logOut",
				"onServerExecute": this.logOut, 
				"parameters": {
					"user": {
						"type": "object",
						"required": true,
						"parameters": {
							"jwtToken": {
									"type": "string",
									"required": true,
									"description": "The user's JWT token to verify."
								}
							}
					}
				},
				"returns": "Returns true when the user has been logged out successfully.",
				"testCases": [
					"logOutTest",
					async (driver: HotTestDriver): Promise<any> =>
					{
						// @ts-ignore
						let resp = await api.users.logOut ({
								jwtToken: driver.persistentData.jwtToken
							});

						driver.assert (resp == true, "User not able to log out!");
					},
					"userLogOutTest",
					async (driver: HotTestDriver): Promise<any> =>
					{
						let decoded: IJWTToken = await User.decodeJWTToken (driver.persistentData.jwtToken);
						const userLoginId: string = decoded.userLoginId;

						/// @todo Verify that the user login was updated with the logout time.

						//driver.assert (resp == true, "User not able to log out!");
					}
				]
			});
		this.addMethod ({
				"name": "forgotPassword",
				"onServerExecute": this.forgotPassword, 
				"parameters": {
					"user": {
						"type": "object",
						"required": true,
						"parameters": {
							"jwtToken": {
									"type": "string",
									"required": true,
									"description": "The user's JWT token to verify."
								}
							}
					}
				},
				"returns": "Returns true when the user has been logged out successfully.",
				"testCases": [
					"forgotPasswordTest",
					async (driver: HotTestDriver): Promise<any> =>
					{
						// @ts-ignore
						let resp = await api.users.forgotPassword ({
								jwtToken: driver.persistentData.jwtToken
							});

						driver.persistentData.verificationCode = resp;

						driver.assert (resp !== "", "User not able to start forgotten password process!");
					}
				]
			});
		this.addMethod ({
				"name": "verifyForgotPasswordCode",
				"onServerExecute": this.verifyForgotPasswordCode, 
				"description": "Verifies the forgotten password code received by the user and resets their password.",
				"parameters": {
					"user": {
						"type": "object",
						"required": true,
						"parameters": {
							"jwtToken": {
									"type": "string",
									"required": true,
									"description": "The user's JWT token to verify."
								}
							}
					}
				},
				"returns": "Returns true when the user has been logged out successfully.",
				"testCases": [
					"verifyForgotPasswordCodeTest",
					async (driver: HotTestDriver): Promise<any> =>
					{
						// @ts-ignore
						let resp = await api.users.verifyForgotPasswordCode ({
								email: "test3@freelight.org",
								verificationCode: driver.persistentData.verificationCode,
								newPassword: "asw45as4we5se45se45"
							});

						driver.assert (resp === true, "User not able to start forgotten password process!");
					}
				]
			});
	}

	/**
	 * The user to register.
	 */
	protected async register (req: ServerRequest): Promise<any>
	{
		const user: User = HotStaq.getParam ("user", req.jsonObj, true);

		HotStaq.getParam ("email", user, true);
		HotStaq.getParam ("password", user, true);

		let newUser: User = new User (user);

		if (this.connection.processor.mode !== Hot.DeveloperMode.Development)
			newUser.verified = true;

		await newUser.register (this.db);

		return (newUser);
	}

	/**
	 * The user login.
	 */
	protected async login (req: ServerRequest): Promise<any>
	{
		const user: User = HotStaq.getParam ("user", req.jsonObj);

		const email: string = HotStaq.getParam ("email", user);
		const password: string = HotStaq.getParam ("password", user);
		const ip: string = (<string>req.req.headers["x-forwarded-for"]) || req.req.socket.remoteAddress;

		let userInfo: User = await User.login (this.db, ip, email, password);

		return (userInfo);
	}

	/**
	 * Verify a user.
	 */
	protected async verifyUser (req: ServerRequest): Promise<any>
	{
		const email: string = HotStaq.getParam ("email", req.jsonObj);
		const verificationCode: string = HotStaq.getParam ("verificationCode", req.jsonObj);

		await User.verifyUser (this.db, email, verificationCode);

		return (true);
	}

	/**
	 * The user logout.
	 */
	protected async logOut (req: ServerRequest): Promise<any>
	{
		const jwtToken: string = HotStaq.getParam ("jwtToken", req.jsonObj);

		await User.logOut (this.db, jwtToken);

		return (true);
	}

	/**
	 * Starts the forgotten password process.
	 */
	protected async forgotPassword (req: ServerRequest): Promise<any>
	{
		const jwtToken: string = HotStaq.getParam ("jwtToken", req.jsonObj);

		let verificationCode: string = await User.forgotPassword (this.db, jwtToken);

		return (verificationCode);
	}

	/**
	 * Verifies the forgotten password code and resets the user's password.
	 */
	protected async verifyForgotPasswordCode (req: ServerRequest): Promise<any>
	{
		const email: string = HotStaq.getParam ("email", req.jsonObj);
		const verificationCode: string = HotStaq.getParam ("verificationCode", req.jsonObj);
		const newPassword: string = HotStaq.getParam ("newPassword", req.jsonObj);

		await User.resetForgottenPassword (this.db, email, verificationCode, newPassword);

		return (true);
	}
}